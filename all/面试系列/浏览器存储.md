浏览器的本地存储主要分为 `Cookie`、`Web Storage` 和 `IndexedDB`

##### cookie

`Cookie` 最开始被设计出来其实并不是来做本地存储的，而是为了弥补 `HTTP` 在状态管理上的不足。

`HTTP` 是无状态的，即它不会记住用户的操作，这让我们在记住用户状态等场景被限制，所以有了 `Cookie`

`Cookie` 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储。

向同一个域名下发送请求，都会携带相同的 `Cookie`，服务器拿到 `Cookie` 进行解析，便能拿到客户端的状态。

缺陷：

1. **容量缺陷**。体积上线 `4kb`，只能存储少量信息。
2. **性能缺陷**。`Cookie` 请求每次都会携带上完整的 `Cookie`，随着请求数增多，造成性能浪费。
3. **安全缺陷**。以纯文本的形式在浏览器和服务器中传递，容易被非法截获和篡改。

##### storage

`Local Storge` 相对 `Cookie` 而言，它也是针对同一个域名。

同一个域名下，会存储相同的一段 `Local Storage`。

相比 `Cookie` 优势：

1. **容量**。体积上线 `5M`，大于 `Cookie` 的 `4kb`。
2. **只存在客户端**。不参与和服务端的通讯，避免 `Cookie` 的性能缺陷和安全缺陷。
3. **接口封装**。有 `setItem` 和 `getItem` 两个 API 接口。

**应用场景**：

- 以 `Base64` 方式存储官方 Logo 等图片。



Session Storage 基本上和 `Local Stoarge` 一致。

相比较上的不同：

- 会话级别的存储。不同于 `Local Storage` 的持续化存储，`Session Storage` 当页面关闭的时候就不复存在了。

**应用场景**：

1. 对表单信息做维护。用户刷新页面不丢失。
2. 存储本次浏览记录。看过的页面不怕找不到。



##### IndexedDB

`IndexedDB` 是运行在浏览器中的 **非关系型数据库**。

因为本质上是数据库，所以一般来说容量是没有上线的。

但是目前还没有尝试一番，所以这里就不哆嗦了。



##### Token

众所周知，`HTTP` 是无状态协议，即它对于交互性场景没有记忆能力。

但是，如果碰到某些场景，就有点无奈了：

1. 输入账号密码进行登录
2. 将商品加入购物车
3. 点击支付，发现用户要重新登录

我们还可以通过 `token` 来维持用户的登录态：

>  用户 id + 过期时间 + SecretKey

```
"用户 id" + "过期时间" + SHA1("用户 id" + "用户口令" + "过期时间" + "SecretKey")
```

这样，当浏览器发送请求给服务器，`token` 会通过 `cookie` 等形式将上面实例内容传输给服务器。

服务器拿到数据后，根据用户 `id` 查找用户口令，并进一步计算是否已过期，从而判断用户是否需要重新登录。

需要重新登录则跳转到登录页面，不需要重新登录则进行支付流程。

总结：

+ cookie由服务器发给浏览器去管理，发送请求时直接携带cookie就可以了

+ session代表的是一种抽象的一对一会话机制，cookie只是目前实现这种机制的主流方案里面的一个参与者

  它一般是用于保存session ID。

  sessionid是一个会话的key，浏览器第一次访问服务器会在服务器端生成一个session，有一个sessionid和它对应。服务端在创建了Session的同时，会为该Session生成唯一的sessionId，而sessionId会在随后的请求中会被用来重新获得已经创建的Session；Session被创建之后，就可以调用Session相关的方法往Session中增加内容了，而这些内容只会保存在服务器中，发到客户端的只有sessionId；当客户端再次发送请求的时候，会将这个sessionId带上，服务器接受到请求之后就会依据sessionId找到相应的Session，从而再次使用之。

  当客户端第一次请求session对象时候，服务器会为客户端创建一个session，并将通过特殊算法算出一个session的ID，用来标识该session对象。

+ token由服务器颁发给前端，前端发起请求时携带即可

  ​

